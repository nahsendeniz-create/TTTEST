<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top Uçuş Yörüngesi Simülasyonu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="flex flex-col items-center justify-center p-6 bg-gray-800 rounded-3xl shadow-2xl max-w-4xl mx-auto space-y-6">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-white mb-2">Top Uçuş Yörüngesi Simülasyonu</h1>
        <p class="text-gray-400 text-center max-w-xl">
            Aşağıdaki ayarları kullanarak topun uçuş yörüngesini simüle edin.
        </p>

        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full flex justify-center items-center rounded-2xl overflow-hidden bg-gray-900 shadow-lg" style="height: 50vh;">
            <canvas id="render-canvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="w-full grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-gray-700 rounded-2xl">
            <!-- Initial Velocity -->
            <div class="flex flex-col items-center">
                <label for="velocity" class="text-sm font-medium text-gray-300">Başlangıç Hızı (m/s)</label>
                <div class="flex items-center w-full mt-1">
                    <input type="range" id="velocity" name="velocity" min="10" max="100" value="50" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="velocity-value" class="ml-3 text-white font-mono">50</span>
                </div>
            </div>

            <!-- Angle -->
            <div class="flex flex-col items-center">
                <label for="angle" class="text-sm font-medium text-gray-300">Açı (derece)</label>
                <div class="flex items-center w-full mt-1">
                    <input type="range" id="angle" name="angle" min="10" max="80" value="45" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="angle-value" class="ml-3 text-white font-mono">45</span>
                </div>
            </div>

            <!-- Gravity -->
            <div class="flex flex-col items-center">
                <label for="gravity" class="text-sm font-medium text-gray-300">Yer Çekimi (m/s²)</label>
                <div class="flex items-center w-full mt-1">
                    <input type="range" id="gravity" name="gravity" min="1" max="20" value="9.8" step="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="gravity-value" class="ml-3 text-white font-mono">9.8</span>
                </div>
            </div>
        </div>

        <!-- Buttons and Info -->
        <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4 w-full">
            <button id="start-button" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition-colors duration-300">
                Simülasyonu Başlat
            </button>
            <div id="info-box" class="p-3 bg-gray-700 rounded-xl text-center text-sm text-gray-300">
                Lütfen başlat butonuna tıklayın.
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), antialias: true, alpha: true });
            const canvasContainer = document.getElementById('canvas-container');

            // Set initial camera position
            camera.position.set(0, 20, 100);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // Ground plane
            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x4a5568, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);

            // Ball mesh
            const ballGeometry = new THREE.SphereGeometry(2, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500 });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            scene.add(ball);

            // Trajectory line
            const points = [];
            const trajectoryMaterial = new THREE.LineBasicMaterial({ color: 0x4ade80, linewidth: 2 });
            const trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
            scene.add(trajectoryLine);

            // UI elements
            const velocityInput = document.getElementById('velocity');
            const angleInput = document.getElementById('angle');
            const gravityInput = document.getElementById('gravity');
            const velocityValueSpan = document.getElementById('velocity-value');
            const angleValueSpan = document.getElementById('angle-value');
            const gravityValueSpan = document.getElementById('gravity-value');
            const startButton = document.getElementById('start-button');
            const infoBox = document.getElementById('info-box');

            // Update UI values on input change
            velocityInput.addEventListener('input', () => velocityValueSpan.textContent = velocityInput.value);
            angleInput.addEventListener('input', () => angleValueSpan.textContent = angleInput.value);
            gravityInput.addEventListener('input', () => gravityValueSpan.textContent = gravityInput.value);

            let startTime = 0;
            let isAnimating = false;
            let initialVelocity, angleInRad, gravity;

            function calculateTrajectoryPoints() {
                const points = [];
                const maxT = (2 * initialVelocity * Math.sin(angleInRad)) / gravity;
                const step = maxT / 100;

                for (let t = 0; t <= maxT; t += step) {
                    const x = initialVelocity * Math.cos(angleInRad) * t;
                    const y = initialVelocity * Math.sin(angleInRad) * t - 0.5 * gravity * t * t;
                    points.push(new THREE.Vector3(x, y, 0));
                }
                return points;
            }

            function updateTrajectoryLine() {
                const newPoints = calculateTrajectoryPoints();
                trajectoryGeometry.setFromPoints(newPoints);
                trajectoryLine.geometry.attributes.position.needsUpdate = true;
            }

            startButton.addEventListener('click', () => {
                initialVelocity = parseFloat(velocityInput.value);
                angleInRad = THREE.MathUtils.degToRad(parseFloat(angleInput.value));
                gravity = parseFloat(gravityInput.value);

                isAnimating = true;
                startTime = Date.now();
                
                // Reset ball position
                ball.position.set(0, 0, 0);

                // Update trajectory line to show the path before animation
                updateTrajectoryLine();
                infoBox.textContent = "Simülasyon başladı...";
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Handle canvas resizing
                const width = canvasContainer.clientWidth;
                const height = canvasContainer.clientHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                if (isAnimating) {
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    const x = initialVelocity * Math.cos(angleInRad) * elapsedTime;
                    const y = initialVelocity * Math.sin(angleInRad) * elapsedTime - 0.5 * gravity * elapsedTime * elapsedTime;

                    ball.position.set(x, y, 0);

                    // Stop animation when ball hits the ground
                    if (y <= 0) {
                        isAnimating = false;
                        ball.position.y = 0; // Snap to ground
                        const finalX = initialVelocity * initialVelocity * Math.sin(2 * angleInRad) / gravity;
                        infoBox.textContent = `Top yaklaşık ${finalX.toFixed(2)} metre uzağa düştü.`;
                    }
                }

                renderer.render(scene, camera);
            }

            animate();
        };
    </script>
</body>
</html>
